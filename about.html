<!DOCTYPE html>
<html>
	<head>
		<title>Plus de détails sur les projets</title>
		<meta charset="utf-8">
		<link rel="stylesheet" href="style.css">
	</head>
	<body>
        <h1 id="top">Portfolio | Détails des projets</h1>
		<nav>
			<ul>
				<h3>Sommaire</h3>
				<li><a href="index.html">Page d'accueil du portfolio</a></li>
				<br>
				<li><a href="#mctdl">Minecraft Tournoi des Légendes (Java)</a></li>
				<li><a href="#interpretor">HTMLInterpretor (Java)</a></li>
				<li><a href="#ascii">Video To ASCII (C++)</a></li>
				<li><a href="#yol">Your Own Legend (Java)</a></li>
				<!--<li><a href="#">SCREncoder (Java)</a></li> -->
				<li><a href="#youtoube">NSI - Youtoube (Python)</a></li>
				<li><a href="#a_mazing_game">NSI - A Mazing Game (Python)</a></li>
				<!-- <li><a href="#">Another Java Game (Java)</a></li> -->
			</ul>
	</nav>
		<br><br><br>
		<div id="mctdl" class="desc">
			<hr>
			<h2>Minecraft Tournoi des Légendes</h2>
			<p>Ce projet est assez ambitieux dans le sens où il est nécessaire d'avoir de nombreux modes de jeu disponibles pour le considérer comme terminé.
				<br> Le <strong>Meltdown</strong> est aujourd'hui le seul mode de jeu qui peut être considéré comme complètement terminé et c'est donc sur ce mode en particulier que cette présentation va détailler.
				<br><br>
				Les jeux ont été imaginés pour être joué à 8 équipes de 4 joueurs. Par leurs performances individuelles et collective, les joueurs gagnent des Coins. Ces Coins sont liés à leur profile et sert à avoir un classement personnel.
				L'équipe rassemble la somme des Coins de chacun de ses membres, de cette façon on peut les classer.
				<br> Le Meltdown est basé sur la coopération entre les joueurs d'une équipe. En effet, une équipe est éliminée seulement si tous ses joueurs sont congelés. De plus, la pioche servant à récupérer les blocs de Coins ne peuvent être utilisés que par un
				joueur de l'équipe à la fois. Il est donc primordiale de s'organiser afin de pouvoir obtenir le plus d'or possible en éliminant les équipes adverse.
				<br> Le meltdown est organisé en salles, qui s'ouvrent au fur et à mesure que le temps passe.
			</p>
			<img src="more_props/image/meltdown_map.png" class="demo_img2">
			<p>
				Les salles aux extrêmités sont les points d'apparition des équipes. Elles ont directement accès à la salle devant elles. Les salles d'ouvrent au fur et à mesure, se rapprochant du centre et permettant aux équipes de se rencontrer.
				<br>Pour pousser les joueurs à se rendre au centre, les salles vont progressivement "fondre" à partir d'un certain temps de jeu, d'où le nom "Meltdown". Des alarmes s'activent dans ces salles 1 minute avant qu'elles ne commencent à fondre,
				avec un signal sonore (le tout grace au pack de texture).
			</p>
			<table class="multi_images">
				<tr>
					<td>
						<img src="more_props/image/meltdown_alarm.png" class="demo_img2">
					</td>
					<td>
						<img src="more_props/image/meltdown_ground.png" class="demo_img2">
					</td>
				</tr>
			</table>
			<br>
			<p>Quand un joueur ennemi touche un membre de l'équipe avec un <strong>Freezing Gun</strong>, celui ci se transforme en glace. Il est désormais en mode "spectateur", où il est forcé d'avir le point de vue d'un de ses coéquipier (La caméra libre est empêchée par le plugin).
			Si un membre de son équipe place un <strong>Heater</strong>, il va progressivement décongeler jusqu'à être libéré, le joueur retrouve alors le contrôle de son personnage.
			</p>
			<table class="multi_images">
				<tr>
					<td>
						<img src="more_props/image/meltdown_target.png" class="demo_img2">
					</td>
					<td>
						<img src="more_props/image/meltdown_frozen.png" class="demo_img2">
					</td>
				</tr>
				<tr>
					<td>
						<img src="more_props/image/meltdown_spectatting.png" class="demo_img2">
					</td>
					<td>
						<img src="more_props/image/meltdown_unfreezing.png" class="demo_img2">
					</td>
				</tr>
			</table>
			<p>(Note: les noms des joueurs sont censurés car ils contenaient mon prénom.)</p>
			<br><br>
			<p>
				Quand il ne reste plus qu'une équipe les Coins gagnés durant la partie sont attribués et les joueurs téléportés au Lobby.
			</p>
			<table class="multi_images">
				<tr>
					<td>
						<img src="more_props/image/meltdown_win.png" class="demo_img2">
					</td>
				</tr>
				<tr>
					<td>
						<img src="more_props/image/meltdown_lobby.png" class="demo_img2">
					</td>
				</tr>
			</table>

			
		</div>
		<div id="interpretor" class="desc">
			<hr>
			<h2>HTML Interpreteur</h2>
			<p>Ce projet consiste à prendre du code HTML et à l'afficher, en respectant les balises et les propriétés CSS.
				<br>La page HTML passe d'abord dans un Parser, qui la découpe en tokens. Il y a 8 tokens de HTML:
				<div class="multi_images">
					<ul>
						<li><strong>OPENING_TAG</strong>: une balise ouvrante (<)</li>
						<li><strong>CLOING_TAG</strong>: une balise fermante (</)</li>
						<li><strong>CLOSE_TAG</strong>: fin d'une balise ouvrante (>)</li>
						<li><strong>SELF_CLOSING_TAG</strong>: une balise auto-fermante</li>
						<li><strong>TEXT</strong>: contenu des balises</li>
						<li><strong>RAW_CONTENT</strong>: Contenu entre les balises script et style</li>
						<li><strong>OPENING_TAG</strong>: une balise ouvrante</li>
						<li><strong>EOF</strong>: fin du document</li>
					</ul>
				</div>
				Voici un extrait du Lexer:
			</p>
			<table class="multi_images">
				<tr>
					<td>
						<img src="more_props/image/html_interpretor_lexer.png" class="demo_img2">
					</td>
				</tr>
			</table>
			<p>
				Le Parser va ensuite transformer ces tokens en un arbre de syntaxe abstraite. Ce dernier est ensuite interprété par le Renderer, qui va l'executer. Le resultat sera affiché sur la page.
			</p>
			
			<table class="multi_images">
				<tr>
					<td>
						<img src="more_props/image/html_interpretor_parser.png" class="demo_img2">
					</td>
				</tr>
			</table>
		</div>
		<div id="ascii" class="desc">
			<hr>
			<h2>Video To ASCII</h2>
			<p>
				Ce projet est relativement simple, les difficultés principales que j'ai rencontré sont en rapport avec C++ que je n'utilise pas couramment, les libraires externes et le déploiment.
				La conversion de vidéo en vidéo ascii est simple:
				<br>On décrète qu'un pixel fait 8*12 pixels.
				<br>On divise donc la resolution de la video par 8 et 12.
				<br>On transforme l'image en niveau de gris et selon ce niveau on imprime un caractère sur une image blanche.
				<br>Toutes ces images mises à la suite permettent de faire une video ascii.
				<table class="multi_images">
					<tr>
						<td>
							<img src="more_props/image/video_to_ascii_convert.png" class="demo_img2">
						</td>
					</tr>
					<tr>
						<td>
							<img src="more_props/image/video_to_ascii_transform.png" class="demo_img2">
						</td>
					</tr>
				</table>
				Cette démarche présente un problème: il n'y a pas de son.
				<br>Pour résoudre ce problème il faudrait utiliser une librairie comme FFMpeg.
				<br>Je rencontre en ce moment un problème avec ce projet: le bouton de conversion ne fonctionne plus.
				Si je devais refaire ce problème j'utiliserai Java car j'ai plus d'expérience avec ce langage même si cela risque de prendre plus de temps pour traiter une vidéo.
				Je reprendrai sûrement ce projet un jour pour le passer sous Java, la libraire FFMpeg est disponible aussi dans ce langage.
			</p>
		</div>
		<div id="yol" class="desc">
			<hr>
			<h2>Your Own Legend</h2>
			<p>
				Your Own Legend est mon premier essai de jeu en 3D. C'est un jeu de type Voxel, les cubes sont générés par "Chunk" de 16 blocs par 16 blocs.
				<br>Le joueur est représenté par une caméra qui a une position et une rotattion. A chaque rafraichissement, cette position et rotation sont mises à jour.
				Quand j'ai implémenté cette caméra mon taux de rafraichissement était cappé à 165Hz, la vitesse que j'ai choisi pour le joueur est donc adaptée à ce tauc de rafraichissement.
				Or, ce taux de rafraichissement peut varier d'un ordinateur à l'autre et même ne pas être stable. La vitesse pourrait donc varier en fonction de la configuration de l'ordinateur.
				Pour éviter cela, il suffit de définir la distance parcourue en 1 frame par <i>vitesse / taux de rafraichissement</i>.
				<br> Voici un apreçu de la caméra:
				<table class="multi_images">
					<tr>
						<td>
							<img src="more_props/image/yol_camera.png" class="demo_img2">
						</td>
					</tr>
				</table>
				Maintenant que nous avons une caméra il nous faut un monde.
				<br>La <i>render distance</i> ou distance de rendu est la distance maximale auquel le joueur peut voir. Passé cette distance, le monde ne se génère plus.
				Quand le joueur s'approche suffisamment d'un chunk pour le faire entrer dans la zone de rendu, un Thread vérifie si ce chunk a précédemment été initialisé, et, si non, le génère et le stock.
				<br>Le Thread chargé du récupère tous les chunks générés qui se situent dans le rayon de la distance de rendu et les affiche.
				L'affichage est géré par OpenGL, qui récupère les coordonnées des sommets du cube, sa texture et après la multiplication des coordonnées des sommets par la <i>view matrix, projection matrix et transformation matrix</i> affiche le résultat à l'écran.
				<table class="multi_images">
					<tr>
						<td>
							<img src="more_props/image/yol_update_terrain.png" class="demo_img2">
						</td>
					</tr>
				</table>
				<i>Le generator créer une heightmap suivant l'algorithme du bruit de Perlin.</i>
				<table class="multi_images">
					<tr>
						<td>
							<img src="more_props/image/yol_loop.png" class="demo_img2">
						</td>
					</tr>
				</table>
				<table class="multi_images">
					<tr>
						<td>
							<img src="more_props/image/yol_render.png" class="demo_img2">
						</td>
					</tr>
				</table>
				<i>
					Une fois la position et la rotation de la caméra calculée, les chunks devant être affichés générés et chargés ils sont maintenant affichés.
				</i>
				<table class="multi_images">
					
					<tr>
						<td>
							<img src="more_props/image/yol_entity_renderer.png" class="demo_img2">
						</td>
					</tr>
				</table>

				Ci après vous pouvez retrouver une démonstration du jeu dans son état actuel.
			</p>
			<video src="more_props/image/yol_demo.mp4" type="video/mp4" class="demo_img2" controls></video>
		</div>
		<div id="youtoube" class="desc">
			<hr>
			<h2>Youtoube</h2>
			<p>
				Il s'agit du premier projet en groupe de NSI. Nous avons fait une copie assez simple du site youtube à l'aide de Flask.
				<br>Notre site est divisé en plusieurs pages: les pages d'accueil, tendances et recherche qui affiche une liste de vidéos,les pages liées à l'utilisateur, où il peut voir ses informations, ses vidéos, son historique
				 et finalement la page d'affichage des vidéos qui permet de les lires, de les "aimer" et de poster un commentaire.
				<br>
				<h3>Les pages d'accueil / recherche</h3>
				Ces pages énumèrent les vidéos de la base de données. La page principale liste toutes les vidéos sans logique particulière, la page "tendances" les trie en fonction de leur nombre de vues, et la page recherche les tries selon le titre ou le créateur.
				<table class="multi_images">
					<tr>
						<td>
							<img src="props/youtoube.png" class="demo_img2">
						</td>
					</tr>
				</table>
				<table class="multi_images">
					<tr>
						<td>
							<img src="more_props/image/youtoube_search_1.png" class="demo_img2">
						</td>
						<td>
							<img src="more_props/image/youtoube_search_2.png" class="demo_img2">
						</td>
					</tr>
				</table>

				<br>
				Voici ensuite les pages liées à l'utilisateur.
				<br>Pour y accèder, comme pour accèder à beaucoup d'autres contenu il est nécessaiere de se connecter à son compte (pour accèder à l'espace utilisateur mais aussi pour aimer ou commenter une vidéo).
				Quand un utilisateur essaie d'accèder à une page qui necessite la connexion à un compte alors qu'il n'est pas connecté, un popup de connexion apparait.
				<table class="multi_images">
					<tr>
						<td>
							<img src="more_props/image/youtoube_login_popup.png" class="demo_img2">
						</td>
					</tr>
				</table>
				Dans certains cas (mot de passe incorrect, clic sur le bouton "aimer") l'utilisateur sera redirigé vers la page de connexion elle-même (en l'occurence http://127.0.0.1:5000/login). Une fois la connexion effectuée,
				il sera redirigé sur la page où il se trouvait précédemment: s'il regardait la vidéo "Test" et qu'il tente de la commenter sans être connecté, après s'être connecté il sera redirigé vers cette même vidéo.
				<br>
				Les pages de profil sont accessibles depuis la barre de navigation ouvrable avec le bouton "
				<svg xmlns="http://www.w3.org/2000/svg" width="32" height="auto" fill="currentColor" class="bi bi-list" viewBox="0 0 16 16">
					<path fill-rule="evenodd" d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5"/>
				</svg>".
				<br>Menu déroulant du profil:
				<table class="multi_images">
					<tr>
						<td>
							<img src="more_props/image/youtoube_login.png" class="demo_img2">
						</td>
						<td>
							<img src="more_props/image/youtoube_logged.png" class="demo_img2">
						</td>
					</tr>
				</table>
				Si l'utilisateur n'est pas connecté, cela affiche simplement "Se connecter", s'il est connecté, les différentes pages sont accessibles.
				Page de profil:
				<table class="multi_images">
					<tr>
						<td>
							<img src="more_props/image/youtoube_personnal_datas.png" class="demo_img2">
						</td>
					</tr>
					<tr>
						<td>
							<p>Les vidéos postés par l'utilisateurs:</p>
							<img src="more_props/image/youtoube_my_videos.png" class="demo_img2">
						</td>
					</tr>
					<tr>
						<td>
							<p>L'historique de l'utilisateur (trié par date, le plus récent en haut):</p>
							<img src="more_props/image/youtoube_history.png" class="demo_img2">
						</td>
					</tr>
				</table>
				Toutes les vidéos vues jusqu'à présent sont en réalité des boutons cliquables qui redirigent vers la page de la vidéo.
				<br>La page de la vidéo est composé de la vidéo elle même et de ses informations comme le titre, le créateur, le nombre de vues, le nombre de 'likes'...
				<br>Un formulaire permet d'envoyer des commentaires et un bouton permet d'afficher ceux ci.
				<br>Sur le coté droit, la liste des autres vidéo est disponibles.
				<table class="multi_images">
					<tr>
						<td>
							<img src="more_props/image/youtoube_watch.png" class="demo_img2">
						</td>
					</tr>
					<tr>
						<td>
							<img src="more_props/image/youtoube_comments.png" class="demo_img2">
						</td>
					</tr>
				</table>

				<br>
				Ce projet peut être considéré comme terminé. La partie visuel de ce projet n'était pas notée, on peut donc envisager d'améliorer son esthétique. On peut aussi envisager une amélioration sur le stockage des vidéos.
				En effet, elles sont pour le moment stockées en qualité source, on peut envisager de les compresser pour limiter leur impact sur le stockage du serveur.
				<br>On peut aussi imaginer des améliorations comme l'implémentation d'algorithme de recommendations pour les videos.
			</p>
		</div>
		<div id="a_mazing_game" class="desc">
			<hr>
			<h2>A Mazing Game</h2>
			<p>
				Il s'agit du deuxième projet, seul cette fois ci, de NSI.
				<br>
				<table class="multi_images">
					<tr>
						<td>
							<img src="more_props/image/a_mazing_game_readme.png" class="demo_img2">
						</td>
					</tr>
				</table>
				Voici quelques images du jeu:
				<table class="multi_images">
					<tr>
						<td>
							<img src="more_props/image/a_mazing_game_1.png" class="demo_img2">
						</td>
						<td>
							<p>
								On peut voir le joueur ainsi que des ennemis rouges, noirs et une potion de soin.
							</p>
						</td>
					</tr>
					<tr>
						<td>
							<img src="more_props/image/a_mazing_game_blood.png" class="demo_img2">
						</td>
						<td>
							<p>
								Quand le joueur touche un spike, la texture du spike change et une trainée de sang apparait. Il y a autant de taches de sang par case que le joueur a touché de spike.
								<br>Pour diversifier les taches de sang, la taille, la position et la rotation de la texture varie aléatoirement.
							</p>
						</td>
					</tr>
					<tr>
						<td>
							<img src="more_props/image/a_mazing_game_lamp.png" class="demo_img2">
						</td>
						<td>
							<p>
								Quand le joueur récupère la lampe, son champ de vision augmente pendant une durée déterminée qui varie selon la difficulté.
								<br>Il y a une barre qui indique la durée restante la lampe.
							</p>
						</td>
					</tr>
				</table>
				En cas de victoire ou de défaite, le filtre noir disparait, le chemin qu'a emprunté le joueur s'affiche et on peut voir l'emplacement des objets et ennemis:
				<table class="multi_images">
					<tr>
						<td>
							<img src="more_props/image/a_mazing_game_won.png" class="demo_img2">
						</td>
						<td>
							<img src="more_props/image/a_mazing_game_game_lost.png" class="demo_img2">
						</td>
					</tr>
				</table>
				<br>
				Comme vu plus haut, le comportement des ennemis rouge (mode normal) est assez complexe.
				<br> Tout d'abord savoir si l'ennemi est situé sur une trainée de sang, s'il n'y a pas de trainée de sang sur la carte, il va se diriger directement sur le joueur.
				S'il y a une trainée de sang et qu'il n'est pas dessus, il va se dirigée vers la case de la trainée la plus proche de lui.
				S'il y a une trainée de sang et qu'il est dessus, si le joueur est lui aussi dessus, il va le suivre, sinon il se déplace aléatoirement. L'algorithme utilisé pour chercher le chemin le plus court est le A*.

				<br><br>
				Les ennemis noirs eux suivent simplement le chemin le plus court vers le joueur (A*).
				<br><br>
				Les ennemis jaunes du mode Hunter sont les ennemis au comportement les plus complexes.
				<br>les ennemis jaunes doivent fuir le joueur. Voici l'approche que j'ai utilisé:
				<br>En situation classique ('panic mode' désactivé), l'ennemi cherche d'abord le point le plus loin du joueur (parcourt en largeur mais on retient le dernier point traité).
				Ensuite l'ennemi cherche le point le plus proche du joueur (A*).
				Pour déterminer le chemin à prendre, un algorithme A* modifié est appliqué, il prend en compte le point visé (le plus loin du joueur) tout en essayant d'éviter les cases situées dans le chemin le plus court pour aller au joueur.

				<table class="multi_images">
					<tr>
						<td>
							<img src="more_props/image/a_amzing_game_yellow_move.png" class="demo_img2">
							<img src="more_props/image/a_mazing_game_bfs.png" class="demo_img2">
						</td>
						<td>
							<img src="more_props/image/a_amzing_game_flee.png" class="demo_img2">
						</td>
					</tr>
				</table>

				<br> Ce jeu complètait les objectifs du devoir, néanmoins il me reste un mode à implémenter pour le considérer comme fini.
			</p>
		</div>
		<hr>
		<p>
			Merci d'avoir regardé cette présentation.
		</p>
		<a href="#top">Haut de page</a>
		<br>
		<a href="index.html">Page d'accueil du portfolio</a>
	</body>
</html>
